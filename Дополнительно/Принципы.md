# Основные принципы

## Программируйте на уровне интерфейсов
Представим, что мы разрабатываем в 1С подсистему для отправки электронной почты.
Можно было бы напрямую обращаться к классам поставщиков:
    
    // Плохо
    Почта = ПочтовыйСервисYandex();
    Почта.ВвестиАдресатов(Контрагенты);  
    Почта.ВвестиТекстПисьма(ТекстПисьма);
    Почта.ОтправитьПисьмо();

    Почта = ПочтовыйСервисMail();
    Почта.ЗадатьПолучателей(Контрагенты);
    Почта.ЗадатьТекст(ТекстПисьма);  
    Почта.Отправить();

Но так мы "зашьемся" на конкретном поставщике и его методах. Гораздо лучше ввести универсальный интерфейс:
    
    // Хорошо
    Почта = ПочтовыйСервис.Создать(Поставщик);
    Почта.УстановитьПолучателей(Контрагенты);
    Почта.УстановитьТекст(ТекстПисьма);  
    Почта.Отправить();

Тогда позже при смене поставщика достаточно будет подменить только создание объекта, не меняя вызовы отправки. В 1С мы бы использовали общие модули или обработки в качестве интерфейсов.

## Стремитесь к слабой связанности взаимодействующих объектов
Этот принцип означает, что разные части программы (модули, классы, объекты) должны знать друг о друге как можно меньше.
Представим, что у нас есть процедура печати документа:
    
    // Плохо
    Процедура НапечататьДокумент(Док)
  
        Документ = Док; // сильная связанность
  
        Если ТипЗнч(Док) = Тип("ДокументСчетФактура") Тогда
            // печатаем счет-фактуру
        ИначеЕсли ТипЗнч(Док) = Тип("ДокументСкладскаяНакладная") Тогда
            // печатаем накладную
        И Так Далее... 

    КонецПроцедуры

Это плохо - процедура сильно зависит от конкретных типов документов. Лучше использовать интерфейс:

    Процедура НапечататьДокумент(ДокОбъект)
  
        ДокОбъект.Напечатать();
  
    КонецПроцедуры

    // а типы документов реализуют интерфейс
    Процедура Напечатать() Экспорт
  
        // печать текущего документа
  
    КонецПроцедуры

Теперь процедура печати не зависит от конкретных типов - связанность слабая.
## Следует предусмотреть возможность расширения поведения без изменения существующего кода
Часто в программах требуется добавлять новое поведение, например:
- поддержка новых типов отчетов
- экспорт данных в новые форматы
- новые правила валидации данных

Проблема в том, что редактирование старого рабочего кода чревато ошибками. Поэтому лучше сделать код расширяемым:

- использовать дополнительные модули
- события, обработчики событий
- интерфейсы вместо конкретных классов

Тогда новый код можно добавлять безопасно, не изменяя старый. Это в разы снижает риски поломки системы при расширении функционала.
## Принцип одной обязанности
Функция или процедура должна выполнять только одну задачу. Например, плохим решением будет процедура, которая формирует отчет, отправляет его по email и еще распечатывает на принтере.

    // Плохо
    Процедура СформироватьОтчет() 
        Отчет.Сформировать();  
        ОтправкаПоЭлектроннойПочте(Отчет);  
        УправлениеПечатью
     КонецПроцедуры
        
    // Хорошо
    Функция СформироватьОтчет()  
        Отчет.Сформировать();
    КонецФункции

    Процедура ОтправитьОтчет(Отчет) 
        ОтправкаПоЭлектроннойПочте(Отчет);
    КонецПроцедуры 

    Процедура РаспечататьОтчет(Отчет)
        УправлениеПечатью(Отчет);  
    КонецПроцедуры