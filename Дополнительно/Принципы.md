# SOLID

Принципы SOLID это важные принципы объектно-ориентированного программирования, которые применимы и к разработке в 1С.

## S (Single Responsibility)
Принцип единственной ответственности. Каждый метод должен нести ответственность только за одну вещь. Например, процедура не должна выполнять и вычисления, и запись в регистры, и форматирование данных.

## O (Open/Closed)

Принцип открытости/закрытости. Модули должны быть открыты для расширения, но закрыты для изменения. Например, в 1С это реализуется через общие модули с постфиксом **Переопределяемые** или **Локализация**.

## L (Liskov Substitution)

Принцип подстановки Лисков означает, что при использовании механизма переопределения, поведение и результаты вызова переопределяемых обработок и функций должны соответствовать базовой реализации.

 Это необходимо для сохранения предсказуемости, обеспечения совместимости с типовыми решениями и предотвращения ошибок при обновлении конфигурации. Переопределенные элементы должны возвращать данные в формате близком к базовому, чтобы избежать проблем в вызывающем коде. 

## I (Interface Segregation)

Принцип разделения интерфейса: 
- Функциональность следует разделять на отдельные модули, а не объединять всё в один большой модуль. 
- Также не стоит загромождать интерфейсы модулей методами, которые не нужны. Лучше разделить на несколько интерфейсов по областям.

## D (Dependency Inversion)

Принцип инверсии зависимостей в 1С означает, что общие модули верхнего уровня (например, модуль реализующий бизнес-логику) не должны напрямую зависеть от других общих модулей нижнего уровня (скажем, от модулей реализующих работу с данными). 

Такой подход даёт слабую связанность между уровнями и позволяет менять реализационные модули, не затрагивая бизнес-логику. 

# Основные принципы

## Программируйте на уровне интерфейсов
Представим, что мы разрабатываем в 1С подсистему для отправки электронной почты.
Можно было бы напрямую обращаться к классам поставщиков:
    
    // Плохо
    Почта = ПочтовыйСервисYandex();
    Почта.ВвестиАдресатов(Контрагенты);  
    Почта.ВвестиТекстПисьма(ТекстПисьма);
    Почта.ОтправитьПисьмо();

    Почта = ПочтовыйСервисMail();
    Почта.ЗадатьПолучателей(Контрагенты);
    Почта.ЗадатьТекст(ТекстПисьма);  
    Почта.Отправить();

Но так мы "зашьемся" на конкретном поставщике и его методах. Гораздо лучше ввести универсальный интерфейс:
    
    // Хорошо
    Почта = ПочтовыйСервис.Создать(Поставщик);
    Почта.УстановитьПолучателей(Контрагенты);
    Почта.УстановитьТекст(ТекстПисьма);  
    Почта.Отправить();

Тогда позже при смене поставщика достаточно будет подменить только создание объекта, не меняя вызовы отправки. В 1С мы бы использовали общие модули или обработки в качестве интерфейсов.

## Стремитесь к слабой связанности взаимодействующих объектов
Этот принцип означает, что разные части программы (модули, классы, объекты) должны знать друг о друге как можно меньше.
Представим, что у нас есть процедура печати документа:
    
    // Плохо
    Процедура НапечататьДокумент(Док)
  
        Документ = Док; // сильная связанность
  
        Если ТипЗнч(Док) = Тип("ДокументСчетФактура") Тогда
            // печатаем счет-фактуру
        ИначеЕсли ТипЗнч(Док) = Тип("ДокументСкладскаяНакладная") Тогда
            // печатаем накладную
        И Так Далее... 

    КонецПроцедуры

Это плохо - процедура сильно зависит от конкретных типов документов. Лучше использовать интерфейс:

    Процедура НапечататьДокумент(ДокОбъект)
  
        ДокОбъект.Напечатать();
  
    КонецПроцедуры

    // а типы документов реализуют интерфейс
    Процедура Напечатать() Экспорт
  
        // печать текущего документа
  
    КонецПроцедуры

Теперь процедура печати не зависит от конкретных типов - связанность слабая.
## Следует предусмотреть возможность расширения поведения без изменения существующего кода
Часто в программах требуется добавлять новое поведение, например:
- поддержка новых типов отчетов
- экспорт данных в новые форматы
- новые правила валидации данных

Проблема в том, что редактирование старого рабочего кода чревато ошибками. Поэтому лучше сделать код расширяемым:

- использовать дополнительные модули
- события, обработчики событий
- интерфейсы вместо конкретных классов

Тогда новый код можно добавлять безопасно, не изменяя старый. Это в разы снижает риски поломки системы при расширении функционала.
## Принцип одной обязанности
Функция или процедура должна выполнять только одну задачу. Например, плохим решением будет процедура, которая формирует отчет, отправляет его по email и еще распечатывает на принтере.

    // Плохо
    Процедура СформироватьОтчет() 
        Отчет.Сформировать();  
        ОтправкаПоЭлектроннойПочте(Отчет);  
        УправлениеПечатью
     КонецПроцедуры
        
    // Хорошо
    Функция СформироватьОтчет()  
        Отчет.Сформировать();
    КонецФункции

    Процедура ОтправитьОтчет(Отчет) 
        ОтправкаПоЭлектроннойПочте(Отчет);
    КонецПроцедуры 

    Процедура РаспечататьОтчет(Отчет)
        УправлениеПечатью(Отчет);  
    КонецПроцедуры